# 规范驱动开发

## 旧工作流
举个例子
一家公司，就三个人，三个角色，老板，产品，开发
老板给产品说，我的需求就是下单金额大于100，免去手续费
产品整理成了文档
开发依据文档完成了需求，但是有个 bug，开发写成了大于 200，免去手续费

一年之后，这家公司除了老板，迎来了新产品，新开发，新开发在看代码的时候发现了这个问题，文档里写的是 100，代码里写的是 200。
两个问题
1. 新开发，能确定是 100 or 200 吗？不能，为什么？
	2. 因为产品文档和代码不一致，他不知道哪个是对的，所以这个时候他会去问产品
2. 新产品，能确定是 100 or 200 吗？也不能，为什么？
	3. 因为开发同事给了他一个选项，这个选项让他不能肯定文档上写的是对的

也就是说新开发，新产品，都不能确定是 100 or 200
只是正常的人员更换，为什么会出现这个情况？
这个问题的本质就是，真理本应该是文档，但实际上代码成为了真理
在物理世界上，实际发生了什么，是谁控制的，是文档，还是代码，是代码
所以才说，本应该是真理的文档，却没有变成真理，反而是基于他实现的代码，成为了真理
大家都说文档很重要，但真的遇到问题了，为什么会先看代码呢？文档很重要，但没说出口的下一句是，代码更重要，代码才是真理
这就是当前的需求工作流面临的问题，这个问题，几乎无解


## 新工作流
- 接下里我们介绍 SDD，主要就是介绍 SDD 到底是怎么解决“代码即真理，文档成为附属”的
- 我们先看第一种方案，就是每次写完代码，我们都把文档补齐，这样行不行，有什么问题？也就是说我们认为代码即真理，是因为纪律性问题，只要纪律性好，就能解决这个问题，这个方案听上去很完美对吧
- 但这里我想问大家一个问题，就是每次写代码，写完代码更新文档，这个每次写的时候，我们是看着代码写的，还是看着文档写的？
- 是看着代码写的对吧，所以就算我们纪律很好，做到了这一点，代码本身还是真理，但是我们要解决的就是让代码本身成为附属品，而不是真理，所以这个问题就不是一个纪律性问题，而是更深层次的，结构性的问题。
- 那究竟要怎么做，怎么做才能让代码成为附属品，文档成为真理
- 很简单，让写代码变成翻译。让文档和代码真正的关联起来
- 之前是需求文档 -> 代码
- 现在是需求文档 -> AI -> 代码
- 这里的重点就是代码不是人写的，是通过规范生成的，也就是说代码是通过文档来生成的
- 我们的工作从完全写代码，转变到写 AI 友好的文档
- 我们把这个文档给到 AI，让 AI 来把这份文档翻译成代码
- 这样只要文档在，代码可以随时随地重新生成
- 好这个时候来看两个问题，假如生产出现了一个紧急的 bug，这个 bug 开发直接自己修复了，然后提交，但是没改规范文档
- 那下次我们重新让  AI 根据规范文档重构这个功能的时候，这个 bug 一定还存在对吗？因为修复bug的人没有改规范文档
- 如果是新需求呢，如果新需求基于这个规范文档，但是这个文档本身有bug，那这个新需求也一定有 bug
- 这就是SDD的核心
- 之前的开发流程 改了代码 -> 不更新文档 -> 零后果，因为大家都是看代码开发，所以都会注意
- 现在的开发流程 改了代码 -> 不更新文档  -> 依赖这个文档的全部都报错，因为大家都是文档驱动开发
- 所以 SDD 让不更新文档这件事情，产生了痛觉，如果大家都这么做，你不这么做，那你就会让整个项目产生问题
- ok，我们解释了 SDD 规范的核心之后，现在把讨论推向下一层
- 就是“代码是规范的产物”这件事情本身大家觉得成立吗？
- 我个人认为，现在的 llm 能力一定是足够的，足够做到“代码是规范的产物”
- 那为什么谈到这件事情，大家还是会有些抵触呢？这里的瓶颈是什么？
- 这里的瓶颈就是我们要清晰明确的告诉 llm 要这么做
- 也就说之前我们的工作是“把一件事情做出来”现在的工作是“把一件事情说清楚”，那这两个哪个更难呢？
- 对于大部分人来说，都是“把一件事情说清楚”更难，因为把需求做出来，并不一定能说明白，但是能把一个需求事情说明白，就一定能做出来，因为代码本身就是物理时间逻辑的翻译
- 我还是举个例子，“用户登陆失败三次，锁定15分钟”，我们在写文档的时候，就必须考虑，是连续还是累计，要不要跨浏览器，如果15分钟重制了密码，要不要放开，这些逻辑可能在写代码时候被发现，但是 SDD 就要求了我们必须在写规范的时候，就确定这些
- 所以复杂度并没有消失，复杂度只是从边写边想，转移到了，最开始
- 所以这种“强迫先想清楚的”要求，对于开发来说，是好事，还是坏事？是好事对吧？
- 真的是好事吗？我们在往深入想一下，有两个公司，两个公司要做同一件事情，这个事情需求不明确，技术方案也不明确，公司A，每次都贯穿 SDD 的最佳实践，规范定了5天，写代码花了2天，7天上线，然后发现不符合用户的需求，因为最开始写的规范就错了
- 公司B，根本不写规范，就弄一个最小的产品，然后快速上线，快速验证，他们7天上了三个版本，很早就确定了真实的用户需求
- 公司B就是敏捷开发，公司A，就是瀑布模式，瀑布模式就是说开发流程就像瀑布一样，只能往下走，绝对返工。
- 这里我的问题就是，网上其实也有一种声音在说 SDD 就是 ai 版本的瀑布模式，大家觉得说的对吗？SDD 是 ai 版本的瀑布模式吗？他有瀑布模式的缺点吗？
- 瀑布模式的缺点是什么？是不能推到重来，但是SDD呢？他绝对可以推到重来，并且规范这个东西，你可以写的粗一点，也可以写的细一点，所以“想清楚在干”和“先试一下再说”其实并不冲突，也就说 SDD 本身绝对不是 ai 版本的瀑布模式，他就是未来的开发范式
- 好到这里我们总结一下，SDD 的本质
- 用规范生成代码，代码本身成为规范的产物，从结构上让规范和代码产生关联，并且借助 ai，让代码的推到重来的成本，趋近于零。