---
name: systematic-debugging
description: 在遇到任何 bug、测试失败或意外行为时使用，在提出修复方案之前
---

# 系统化调试

## 概述

随机修复浪费时间并制造新 bug。快速修补掩盖了根本问题。

**核心原则：** 在尝试修复之前**总是**找到根本原因。症状修复就是失败。

**违反此流程的文字就是违反调试的精神。**

## 铁律

```
没有根本原因调查，就没有修复
```

如果你还没有完成第一阶段，你就不能提出修复方案。

## 何时使用

用于**任何**技术问题：
- 测试失败
- 生产环境中的 bug
- 意外行为
- 性能问题
- 构建失败
- 集成问题

**在以下情况尤其要使用：**
- 时间紧迫（紧急情况让人想猜测）
- "就一个快速修复"似乎很明显
- 你已经尝试了多种修复
- 之前的修复没有生效
- 你不完全理解问题

**不要跳过：**
- 问题看起来简单（简单 bug 也有根本原因）
- 你很匆忙（匆忙保证返工）
- 经理要求立即修复（系统化比胡乱尝试更快）

## 四个阶段

在完成每个阶段之前，你必须完成该阶段。

### 第一阶段：根本原因调查

**在尝试任何修复之前：**

1. **仔细阅读错误消息**
   - 不要跳过错误或警告
   - 它们通常包含确切的解决方案
   - 完整阅读堆栈跟踪
   - 注意行号、文件路径、错误代码

2. **持续复现**
   - 你能可靠地触发它吗？
   - 确切的步骤是什么？
   - 每次都发生吗？
   - 如果不能复现 → 收集更多数据，不要猜测

3. **检查最近的变更**
   - 什么变更可能导致这个问题？
   - Git diff、最近的提交
   - 新依赖、配置变更
   - 环境差异

4. **在多组件系统中收集证据**

   **当系统有多个组件时（CI → 构建 → 签名，API → 服务 → 数据库）：**

   **在提出修复方案之前，添加诊断工具：**
   ```
   对于每个组件边界：
     - 记录什么数据进入组件
     - 记录什么数据从组件输出
     - 验证环境/配置传播
     - 检查每层的状态

   运行一次收集证据，显示它在哪里中断
   然后分析证据以识别失败的组件
   然后调查该特定组件
   ```

   **示例（多层系统）：**
   ```bash
   # 第1层：工作流
   echo "=== 工作流中可用的 secrets： ==="
   echo "IDENTITY: ${IDENTITY:+SET}${IDENTITY:-UNSET}"

   # 第2层：构建脚本
   echo "=== 构建脚本中的环境变量： ==="
   env | grep IDENTITY || echo "环境中没有 IDENTITY"

   # 第3层：签名脚本
   echo "=== 钥匙串状态： ==="
   security list-keychains
   security find-identity -v

   # 第4层：实际签名
   codesign --sign "$IDENTITY" --verbose=4 "$APP"
   ```

   **这揭示了：** 哪一层失败（secrets → 工作流 ✓，工作流 → 构建 ✗）

5. **追踪数据流**

   **当错误在调用栈深处时：**

   查看本目录中的 `root-cause-tracing.md` 了解完整的反向追踪技术。

   **快速版本：**
   - 坏值从哪里开始？
   - 谁用坏值调用了这个？
   - 一直向上追踪直到找到源头
   - 在源头修复，而不是在症状处

### 第二阶段：模式分析

**在修复之前找到模式：**

1. **找到工作示例**
   - 在同一代码库中找到类似的工作代码
   - 什么有效，与损坏的类似？

2. **与参考对比**
   - 如果实现模式，完整阅读参考实现
   - 不要略读——阅读每一行
   - 在应用之前完全理解该模式

3. **识别差异**
   - 工作的和损坏的之间有什么不同？
   - 列出每个差异，无论多小
   - 不要假设"那不可能有影响"

4. **理解依赖关系**
   - 这需要什么其他组件？
   - 需要什么设置、配置、环境？
   - 它做什么假设？

### 第三阶段：假设和测试

**科学方法：**

1. **形成单一假设**
   - 清楚地陈述："我认为 X 是根本原因，因为 Y"
   - 写下来
   - 具体，不要模糊

2. **最小化测试**
   - 做最小的可能变更来测试假设
   - 一次一个变量
   - 不要同时修复多个东西

3. **在继续之前验证**
   - 有效？→ 第四阶段
   - 无效？形成新假设
   - 不要在上面添加更多修复

4. **当你不知道时**
   - 说"我不理解 X"
   - 不要假装知道
   - 寻求帮助
   - 更多研究

### 第四阶段：实施

**修复根本原因，而不是症状：**

1. **创建失败测试用例**
   - 最简单的可能复现
   - 尽可能使用自动化测试
   - 如果没有框架，使用一次性测试脚本
   - 在修复之前必须有
   - 使用 `superpowers:test-driven-development` skill 编写正确的失败测试

2. **实施单一修复**
   - 解决已识别的根本原因
   - 一次一个变更
   - 没有"既然我在这里"的改进
   - 没有捆绑重构

3. **验证修复**
   - 测试现在通过了？
   - 没有其他测试被破坏？
   - 问题实际上解决了？

4. **如果修复不起作用**
   - STOP
   - 计数：你已经尝试了多少修复？
   - 如果 < 3：返回第一阶段，用新信息重新分析
   - **如果 ≥ 3：STOP 并质疑架构（下面的第5步）**
   - 在没有架构讨论的情况下不要尝试第4个修复

5. **如果 3+ 修复失败：质疑架构**

   **表示架构问题的模式：**
   - 每个修复在不同的地方揭示新的共享状态/耦合/问题
   - 修复需要"大规模重构"才能实现
   - 每个修复在其他地方产生新症状

   **STOP 并质疑基本原则：**
   - 这个模式从根本上是否合理？
   - 我们是否"纯粹出于惯性而坚持它"？
   - 我们应该重构架构而不是继续修复症状吗？

   **在尝试更多修复之前与你的合作伙伴讨论**

   这不是失败的假设——这是错误的架构。

## 危险信号 - STOP 并遵循流程

如果你发现自己想：
- "暂时快速修复，以后再调查"
- "试试改改 X，看看是否有效"
- "添加多个变更，运行测试"
- "跳过测试，我会手动验证"
- "可能是 X，让我修复它"
- "我不完全理解，但这可能有效"
- "模式说 X，但我会以不同方式改编"
- "主要问题是：[列出修复而不调查]"
- 在追踪数据流之前提出解决方案
- **"再试一次修复"（已经尝试了 2+ 次）**
- **每个修复在不同的地方揭示新问题**

**所有这些都意味着：STOP。返回第一阶段。**

**如果 3+ 修复失败：** 质疑架构（见第 4.5 阶段）

## 常见借口

| 借口 | 现实 |
|------|------|
| "问题很简单，不需要流程" | 简单问题也有根本原因。流程对简单 bug 很快。 |
| "紧急情况，没有时间做流程" | 系统化调试比猜测-检查胡乱尝试更快。 |
| "先试试这个，然后再调查" | 第一个修复设定了模式。从一开始就做对。 |
| "确认修复有效后我会写测试" | 未经测试的修复不会持久。先测试证明它。 |
| "同时做多个修复节省时间" | 无法隔离什么有效。会导致新 bug。 |
| "参考太长，我会改编模式" | 部分理解保证会有 bug。完整阅读。 |
| "我看到问题了，让我修复它" | 看到症状 ≠ 理解根本原因。 |
| "再试一次修复"（在 2+ 次失败后） | 3+ 失败 = 架构问题。质疑模式，不要再修复。 |

## 快速参考

| 阶段 | 关键活动 | 成功标准 |
|------|---------|---------|
| **1. 根本原因** | 阅读错误、复现、检查变更、收集证据 | 理解**什么**和**为什么** |
| **2. 模式** | 找到工作示例、对比 | 识别差异 |
| **3. 假设** | 形成理论、最小化测试 | 确认或新假设 |
| **4. 实施** | 创建测试、修复、验证 | Bug 解决，测试通过 |

## 支持技术

这些技术是系统化调试的一部分，在本目录中可用：

- **`root-cause-tracing.md`** - 向后追踪 bug 穿过调用栈找到原始触发点
- **`defense-in-depth.md`** - 找到根本原因后在多层添加验证
- **`condition-based-waiting.md`** - 用条件轮询替换任意超时

**相关 skills：**
- **superpowers:test-driven-development** - 用于创建失败测试用例（第4阶段，第1步）
- **superpowers:verification-before-completion** - 在声称成功之前验证修复有效