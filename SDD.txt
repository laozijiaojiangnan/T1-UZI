# 规范驱动开发

## 旧工作流
举个例子
一家公司，就三个人，三个角色，老板，产品，开发
老板给产品说，我的需求就是下单金额大于100，免去手续费
产品整理成了文档
开发依据文档完成了需求，但是有个 bug，开发写成了大于 200，免去手续费

一年之后，这家公司除了老板，迎来了新产品，新开发，新开发在看代码的时候发现了这个问题，文档里写的是 100，代码里写的是 200。
两个问题
1. 新开发，能确定是 100 or 200 吗？不能，为什么？
	2. 因为产品文档和代码不一致，他不知道哪个是对的，所以这个时候他会去问产品
2. 新产品，能确定是 100 or 200 吗？也不能，为什么？
	3. 因为开发同事给了他一个选项，这个选项让他不能肯定文档上写的是对的

也就是说新开发，新产品，都不能确定是 100 or 200
只是正常的人员更换，为什么会出现这个情况？
这个问题的本质就是，真理本应该是文档，但实际上代码成为了真理
在物理世界上，实际发生了什么，是谁控制的，是文档，还是代码，是代码
所以才说，本应该是真理的文档，却没有变成真理，反而是基于他实现的代码，成为了真理
大家都说文档很重要，但真的遇到问题了，为什么会先看代码呢？文档很重要，但没说出口的下一句是，代码更重要，代码才是真理
这就是当前的需求工作流面临的问题，这个问题，几乎无解
直到 llm 的出现



在现有的工作流下，对于一个真实逻辑的客观解释存在两种
1. 需求文档
2. 代码
这两个都在描述一件事情，也就是“需求本身”



## 新工作流
- 文档及代码，我们的所有文档，都是最新版本，大家了解需求不需要看代码，任何人都不需要看代码，只要看文档，就能知道完整的逻辑，这才是可读性的最高层次，你不需要会代码，只需要会自然语言，你就能看懂代码
- 因为权利发生了反转，代码不是关键，文档才是

