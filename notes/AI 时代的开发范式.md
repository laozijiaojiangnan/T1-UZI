- 有了 ai 之后的编码发生了哪些变化

###  AI 编程时代的四个等级
- 大致分为四个阶段
- leve 1: AI 作为知识库
	- 关键节点（chat gpt）
	- chat gpt 出现之后的一段时间内，我们通过对代码进行精简、提取的方式，发给大模型，大模型根据有限的上下文给出回答，我们再把回答复制到 ide 里，完成代码的撰写
	- 这个阶段，代码的读取、写入、提示词的上下文构建，全部是程序员人工整理，大模型只能根据程序员人工整理的提示词，构造回答
- leve 2: AI 接入 IDE
	- 关键节点（ai 原生 ide 的出现, cursor ）
	- cursor 的出现，最重要的工作就是把 llm 搬到了 ide 里面，让我们在 ide 里和 llm 交互，这个阶段的核心功能是代码补全，和简化了等级1里，我们复制粘贴的工作，上下文提供更加的清晰和方便，大模型开始介入代码的读取、写入，这个阶段算是很多人的舒适区，但是我本质上这个阶段还是辅助编程，并且因为 ide 的存在 ai 的能力被锁死在 ide 内部，一旦 ide 关闭了，工作流也就结束了
- level 3: Coding Agent
	- 关键节点（claude code）
	- ai 从代码补全转变为完整实现一个需求的所有代码，这个期间，人来辅助 ai 写代码，而不是反过来。
	- ai 自己去**规划 -> 读文件 -> 改代码 -> 跑测试**，直到 ai 认为当前任务完成。
	- 这个阶段，程序员真正的从代码的作者（或者说执行者）变成了（审批者）
	- 像 cursor 的 agent、trae 的 sole 也都是 agent 模式
	- 那比如 ai ide 在右边聊天框，通过对话的形式，写代码是不是也是 agent 模式？是的，也属于 agent，那 cursor 的 agent 和 claude code 的 agent 具体有什么区别，在后面的分享也会聊到，
	- 这里简单提一句就是环境，ai ide 是非常棒的实践，但是他还是被旧时代的思想影响了，ai 被锁死在 ide 里面了，但是像 claude code，opencode，codex 他们是 cli，cli 可以在任何环境下安装，你可以在服务器上跑，可以在 docker 上跑，ai 的能力没有被锁死在一个地方。一个是只能帮你写代码，一个是既能帮你写代码有能帮你维护代码，这就是区别
- level 4: AI 自主编程（人人都是程序员）
	- 关键节点
	- 端到端的解决应用层的所有问题，开发，测试，上线，监控，修 bug，一系列问题。
	- 未来大家大家人人都是程序员，不用去纠结一个东西要怎么做，而是聚焦于做什么
	- 当然这个未来什么时候来，我也不确定，但是我觉得这中间还是有很多问题要解决的，那我认为里面一个很棘手的问题就是，出错了谁来负责，难道一个需求在生产出问题了，我要去和 claude code 说，你把这个锅背一下？不可能的对吧


###  程序员的核心价值
- AI 时代之前的程序员核心价值
	- 在介绍 sdd 之前，我们先讨论一下传统开发流程，讨论一下 ai 时代之前，程序员的核心价值
	- 需求文档 -> 技术方案 -> 编码实现 -> 运营维护
	- 在这四个流程里，【编码实现】大概占了70% - 80% 的时间，所以可以说写代码就是我们的核心竞争力
	- 需求文档 -> 技术方案 -> 编码实现 -> 运营维护，这个工作流本身其实存在局限性，也就是大家经常会碰到的，需求文档不能改，为什么不能改，因为需求文档本身就是最底层，最底层的一旦变动，上层全部都会跟着变动，而且有时候一句话的变动，可能涉及编码的很多地方都要变动
		- 所以为了解决这个问题，基本上所有人都在妥协，产品在妥协，为了更快的上线解决问题，开发也在妥协，也是为了更快的上线不耽误进度，代码就开始随意写，然后技术债就产生了，随着这种问题的越来越多，技术债也越累越多，到最后，改不下去，开个新的项目，重构整个框架，然后重复这个过程。
	- 这个问题的根源是什么？就是编码实现这一步，它太重要了，它重要到要让大家都为了它妥协，但是妥协只能解决当前的问题，同时带来了新的问题，只是这个新的问题，产生作用可能就是之后的事情了。
- AI 时代之后的核心价值
	- 在 coding agent 出现之后，核心价值发生了上移，因为最重要的一步，编码实现，可以让 ai 又快又好的来解决了，正常 1 天的编码工作，可能 ai 30分钟就能全部搞定，所以手写代码这件事情本身正在变的廉价，或者说代码本事在变的廉价，那什么变的值钱的了？
	- 【撰写 Spec 文档】【设计 ai 工作流】【质量保障】
	-  未来我们需要花大量的时间和 产品、 ai 、需求提出者，讨论一个需求文档出来，这个需求文档必须是精准清晰的，有验收标准的，不能是模糊的
	- 然后依据这个【需求文档】，撰写一个技术方案，这个技术方案是  ai 友好的，设计完善的，可以在我们设计的一整套的 ai 工作流下，来 保证 ai 写出来的代码质量的下限，这一步是程序员的核心，把我们从写代码的执行者，变成了spec文档和工作流的设计者
	- 之后写代码的工作完全交给 ai，我们只负责测试和 review ai 生成的代码，
	- 如果我们能把上面的工作完成的很好，那就能解决ai时代之前的问题，也就是不为了写代码本身去妥协，需求文档改一行，代码要改 3 天的这种事情再也不会发生了，因为需求文档改了之后，我们只要把文档扔给ai，ai 就会根据我们的设计的工作流，一步一步把代码改完，测试完，然后生成 commit，让我们 review，我们完全从执行者，变成了审批者，当然整个过程绝对不是说我们能当甩手掌柜，只有我们设计的工作流本身有足够强壮的自动化测试来覆盖，才能让刚才的流程真正转起来，所以未来写测试用例的能力也同样的重要。


### AI 时代的开发核心方法论 - 规范驱动开发（SDD）
#### 介绍
- 核心: 权利反转，让需求文档 or 规范称为唯一事实
- 最理想的状态就是：当遇到一个问题了，我们的第一反应不是看代码，而是看文档，首先是可读性上，文档天然就比代码要好，第二是文档是所有人都可以看，用自然语言写的，所以一个公司的任何人都可以轻松的知道这个问题当前是怎么解决的，不需要找别人
- 当遇到需求改动，直接改文档，也只维护文档，至于代码的生成和质量保证，需要我们来设计工作流了
- 未来最理想的开发就是：一个需求来了，如果是改动需求，就改之前的文档，如果是新需求，就生成新的文档，然后把这个文档给到 coding agent，agent 根据我们设计的工作流，一步一步，把这个需求实现，测试，最终提交一个 commit，然后我们 review 这个 commit，有问题就继续修改，没问题就结束开发，走到下一步。
- **什么样的规范是 ai 友好的？清晰，明确的**

#### SDD 思想对应的第三方库 spec-kit
```
# 1. 进入项目，启动 AI 代理
claude

# 2. 建立项目宪法（一次性）
/speckit.constitution 制定代码质量、测试标准、UX一致性原则

# 3. 创建功能规范（聚焦 What/Why）
/speckit.specify 实现用户认证系统，支持邮箱+密码和 OAuth2

# 4. 澄清需求（消除歧义）
/speckit.clarify

# 5. 技术规划（聚焦 How）
/speckit.plan 使用 NextAuth.js，PostgreSQL 存储用户数据

# 6. 生成任务列表
/speckit.tasks

# 7. 执行实现
/speckit.implement
```

- 这个库本身的缺点要重点说一下，或者说是这个思想在实现上最大的缺点要说一下
- 流程，就真的所有需求都需要这些步骤？这个流程太死了，很不灵活，我如果只是个很简单的功能，也要按照这个流程来，很麻烦。
- 还有需求文档这个东西，现在工作流上本质上还是产品在维护的，不是我们和产品一起维护的，我们还是在产品告诉我们改动之后，再去修改我们的代码
- 再然后就是假如我们真的和产品一起维护需求文档，我们现在能做到就把需求文档丢给 ai，然后中间一步也不看，只看最终的 commit 吗？也不行，其实也做不到
- 所以这个库，我认为想要放到增量的需求上进行开发，其实是很困难的，现有的流程不支持，现有的ai的能力可能也不支持

- 我们只能用它作为参考，然后设计自己的工作流
- 整个流程的优点是什么呢？
- 选择题 vs 填空题
- 确定性 vs 开放时间
- 